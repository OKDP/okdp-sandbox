#
# Copyright 2025 The OKDP Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

name: Build, test and push KuboCD packages

on:
  workflow_call:
    inputs:
      publish_to_registry:
        description: Wheter to push to the registry
        required: false
        type: string
        default: "false"
      registry:
        description: The container registry 
        required: true
        type: string
      ci_registry:
        description: "The registry used to push ci images"
        required: false
        type: string
        default: "ghcr.io"
      oci_package_prefix:
        description: "OCI package prefix, e.g., 'quay.io/my-org/<PACKAGE-PREFIX>', i.e.: <PACKAGE-PREFIX> = sandbox-packages"
        required: true
        type: string
      runs-on:
        description: GitHub Actions Runner image
        required: true
        type: string

defaults:
  run:
    shell: bash

jobs:
  
  kubocd-package:
    runs-on: ${{ inputs.runs-on }}
    steps:

      - name: Checkout Repo âš¡ï¸
        uses: actions/checkout@v4

      # - name: Free up disk space ðŸ“¦
      #   if: inputs.publish_to_registry == 'false'
      #   uses: okdp/gh-workflows/.github/actions/free-disk-space@v1

      - name: Login to the CI registry (${{ inputs.ci_registry }}) ðŸ”
        if: inputs.publish_to_registry == 'false'
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.ci_registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Login into public registry (${{ inputs.registry }}) ðŸ”
        if: inputs.publish_to_registry == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_ROBOT_TOKEN }}

      - name: Set CI Github container registry namespace (${{ inputs.ci_registry }}) ðŸ“¦
        if: inputs.publish_to_registry == 'false'
        run:  |
          echo "OWNER=${GITHUB_REPOSITORY_OWNER@L}" >> $GITHUB_ENV
          echo "REGISTRY=${{ inputs.ci_registry }}" >> $GITHUB_ENV
        shell: bash

      - name: Set public container registry namespace (${{ inputs.registry }}) ðŸ“¦
        if: inputs.publish_to_registry == 'true'
        run:  |
          echo "OWNER=${GITHUB_REPOSITORY_OWNER@L}" >> $GITHUB_ENV
          echo "REGISTRY=${{ inputs.registry }}" >> $GITHUB_ENV
        shell: bash

      # Setup prerequisites
      - name: Set up Kind integration tests cluster ðŸ“¦
        if: inputs.publish_to_registry == 'false'
        uses: okdp/gh-workflows/.github/actions/setup-kind@v1

      - name: Setup helm ðŸ› ï¸
        if: inputs.publish_to_registry == 'false'
        uses: azure/setup-helm@v4.3.1
        with:
          version: v3.18.6
          
      - name: Setup Flux CLI ðŸ› ï¸
        if: inputs.publish_to_registry == 'false'
        uses: fluxcd/flux2/action@main
        with:
          version: '2.6.4'

      - name: Install yq ðŸ› ï¸
        if: inputs.publish_to_registry == 'false'
        run: |
          sudo wget -O /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Deploy Flux (Basic Mode) ðŸš€
        if: inputs.publish_to_registry == 'false'
        run: flux install
      
      - name: Wait until FluxCD controllers are ready âŒ›
        if: inputs.publish_to_registry == 'false'
        run: |
          kubectl wait --for=condition=ready pod -l app=source-controller -n flux-system --timeout=300s

      - name: Verify FluxCD controllers installation âœ…
        if: inputs.publish_to_registry == 'false'
        run: |
          flux version
          kubectl -n flux-system get pods

      - name: Deploy KuboCD controllers on Kind ðŸ› ï¸
        if: inputs.publish_to_registry == 'false'
        run:
          kubectl apply -f clusters/sandbox/flux/kubocd.yaml

      - name: Install KuboCD CLI ðŸ› ï¸
        run: |
          # curl -L -o kubocd https://github.com/kubocd/kubocd/releases/download/v0.2.2/kubocd_Linux_x86_64
          # Temporary fix for: https://github.com/kubocd/kubocd/issues/2
          curl -L -o kubocd https://github.com/kubocd/kubocd/releases/download/v0.2.2/kubocd_fix2_Linux_x86_64

          # Make it executable
          chmod +x kubocd

          # Move to /usr/local/bin
          sudo mv kubocd /usr/local/bin/

          # Verify installation
          kubocd version

      # Build and push packages
      - name: Find KuboCD packages ðŸ”Ž
        run: |
          KUBOCD_PACKAGES=$(find packages -type f \( -name "*.yaml" -o -name "*.yml" \) -exec grep -l '^modules:' {} \; | tr '\n' ' ')
          echo "KUBOCD_PACKAGES=$KUBOCD_PACKAGES" >> $GITHUB_ENV

      - name: Build and push KuboCD packages into CI registry (${{ inputs.ci_registry }}) ðŸ“¦
        if: inputs.publish_to_registry == 'false'
        run: |
          for package in ${KUBOCD_PACKAGES}
          do
             echo "kubocd package ${package} --ociRepoPrefix $REGISTRY/$OWNER/${{ inputs.oci_package_prefix }}"
             kubocd package ${package} --ociRepoPrefix $REGISTRY/$OWNER/${{ inputs.oci_package_prefix }}
          done
        env:
          KCD_OCI_GHCR_IO_USER: ${{ github.actor }}
          KCD_OCI_GHCR_IO_SECRET: ${{ secrets.GITHUB_TOKEN }}

      - name: Create CI registry secret for KuboCD (all release namespaces) ðŸ”
        if: inputs.publish_to_registry == 'false'
        run: |
          release_namespaces="$(
            find clusters/sandbox/releases -type f \( -name "*.yaml" -o -name "*.yml" \) \
              -print0 | xargs -0 -n1 yq eval '.metadata.namespace // "default"' | sort -u
          )"

          echo "Release namespaces:"
          echo "$release_namespaces"

          for ns in $release_namespaces; do
            kubectl create namespace "$ns" --dry-run=client -o yaml | kubectl apply -f -
            kubectl create secret docker-registry ci-registry-secret \
              --docker-server=${{ inputs.ci_registry }} \
              --docker-username="${{ github.actor }}" \
              --docker-password="${{ secrets.GITHUB_TOKEN }}" \
              --docker-email="${{ github.actor }}@users.noreply.github.com" \
              -n "$ns" \
              --dry-run=client -o yaml | kubectl apply -f -
          done

      # Deploy and test installation
      - name: Deploy and test releases on Kind cluster ðŸš€
        if: inputs.publish_to_registry == 'false'
        run: |
          KUBOCD_CONTEXT=clusters/sandbox/default-context.yaml
          KUBOCD_RELEASES=$(find clusters/sandbox/releases -type d ! -exec find {} -type d -mindepth 1 \; | sort -u | tr '\n' ' ')

          echo "Apply context: $KUBOCD_CONTEXT"
          sed "s|${{ inputs.registry }}/$OWNER/${{ inputs.oci_package_prefix }}|${{ inputs.ci_registry }}/$OWNER/${{ inputs.oci_package_prefix }}|g" \
          "$KUBOCD_CONTEXT" | kubectl apply -f -

          # Find all KuboCD releases
          echo "Found KuboCD releases: $KUBOCD_RELEASES"

          for release in $KUBOCD_RELEASES; do
            echo "Applying releases in $release"
            find "$release" -type f \( -name "*.yaml" -o -name "*.yml" \) | while read rel; do
              # Update repository path and add secretRef
              yq eval "
                .spec.package.repository |= sub(\"${{ inputs.registry }}/$OWNER/${{ inputs.oci_package_prefix }}\",\"${{ inputs.ci_registry }}/$OWNER/${{ inputs.oci_package_prefix }}\") |
                .spec.package.secretRef = {\"name\": \"ci-registry-secret\"}
              " "$rel" | kubectl apply -f -
            done
          done

      - name: Test the releases deployment âœ…
        if: inputs.publish_to_registry == 'false'
        run: |
          echo "**************************************** Storage Classes ****************************************"
          kubectl get sc
          kubectl get events -A -w >/tmp/kubectl-events.log 2>&1 &
          EVENTS_PID=$!
          trap 'kill $EVENTS_PID 2>/dev/null || true' EXIT

          # Poll release phase explicitly; this is more stable than kubectl wait for this CRD.
          timeout_secs=1800
          interval_secs=15
          elapsed=0
          ready=0

          while [ "$elapsed" -lt "$timeout_secs" ]; do
            echo "Wait until all KuboCD releases are ready ..."
            echo "************************************** Releases status **************************************"
            kubectl get release -A || true
            echo "**************************************** Pods status ****************************************"
            kubectl get po -A || true
            echo "**************************************** PVC status ****************************************"
            kubectl get pvc -A || true
            echo "**************************************** Pending Pods ****************************************"
            kubectl get pods -A --field-selector=status.phase=Pending \
              -o custom-columns=NS:.metadata.namespace,NAME:.metadata.name --no-headers \
              | xargs -r -n2 sh -c 'echo "Pending Pod: $0/$1 ==="; kubectl describe pod -n "$0" "$1"; echo'

            echo "**************************************** Unhealthy Pods ****************************************"
            kubectl get pods -A --no-headers \
              | awk '$4 ~ /CrashLoopBackOff|Error|ImagePullBackOff|CreateContainerConfigError|CreateContainerError/ {print $1, $2}' \
              | while read -r ns pod; do
                  [ -n "$ns" ] || continue
                  [ -n "$pod" ] || continue
                  echo "Unhealthy Pod: $ns/$pod ==="
                  kubectl describe pod -n "$ns" "$pod" || true
                  containers="$(
                    kubectl get pod -n "$ns" "$pod" -o jsonpath='{range .spec.initContainers[*]}{.name}{"\n"}{end}{range .spec.containers[*]}{.name}{"\n"}{end}' 2>/dev/null || true
                  )"
                  for c in $containers; do
                    echo "--- logs current: $ns/$pod container=$c ---"
                    kubectl logs -n "$ns" "$pod" -c "$c" --tail=200 || true
                    echo "--- logs previous: $ns/$pod container=$c ---"
                    kubectl logs -n "$ns" "$pod" -c "$c" --previous --tail=200 || true
                  done
                  echo
                done

            not_ready="$(kubectl get release -A -o jsonpath='{range .items[?(@.status.phase!="READY")]}{.metadata.namespace}/{.metadata.name}{"\n"}{end}' 2>/dev/null || true)"

            if [ -z "$not_ready" ]; then
              echo "All releases are READY."
              ready=1
              break
            fi

            echo "Releases not ready yet:"
            echo "$not_ready"
            sleep "$interval_secs"
            elapsed=$((elapsed + interval_secs))
          done

          if [ "$ready" -eq 1 ]; then
            exit 0
          fi

          echo "Timed out waiting for READY releases after ${timeout_secs}s"
          kubectl get release -A
          kubectl get helmrelease -A || true
          kubectl get jobs -A || true
          echo "Last events log lines:"
          tail -n 200 /tmp/kubectl-events.log || true
          exit 1
  
      - name: Build and push KuboCD packages into public registry (${{ inputs.registry }}) ðŸ“¦
        if: inputs.publish_to_registry == 'true'
        run: |
          for package in ${KUBOCD_PACKAGES}
          do
             echo "kubocd package ${package} --ociRepoPrefix $REGISTRY/$OWNER/${{ inputs.oci_package_prefix }}"
             kubocd package ${package} --ociRepoPrefix $REGISTRY/$OWNER/${{ inputs.oci_package_prefix }}
          done
        env:
          KCD_OCI_QUAY_IO_USER: ${{ secrets.REGISTRY_USERNAME }}
          KCD_OCI_QUAY_IO_SECRET: ${{ secrets.REGISTRY_ROBOT_TOKEN }}
